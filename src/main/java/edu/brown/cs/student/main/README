PROJECT: Project 1 Sprint

DESCRIPTION: API and KD-Tree

TEAM MEMBERS: Kat, Ben, Sheridan, Livia

Clothing, Review, and Users classes are the java objects in which the Json file is stored. 
They all implement the JSONObject interface so that Java registers that they are of the same type

Received some help from Helen Huang -- helped update JsonHandler.
JsonHandler class reads the json files and convert them into the specific java object (so the rental clothing json file will be stored as a Clothing[] object, etc.)

REPL COMMANDS:
add <number> <number>: adds two numbers together
subtract <number> <number>: substracts one number from the other
stars <file>: FILL IN
naive_neighbors <int> <x> <y> <z>: FILL IN
naive_neighbors <int> <name>: FILL IN
dataGet <users, reviews, rent>: FILL IN
openJson <file> <users, reviews, clothing>: FILL IN


Questions:

 1. From this angle, how might your matchmakerâ€™s results end up treating
 minorities differently than their more privileged counterparts? What larger-reaching
 impacts might this have (e.g. are biases reiterated? Do members of minority
 groups receive as well-suited matches as their peers might? etc.).

As the study mentioned, marginalized communities are less likely to
advocate for themselves or accurately realize/determine their own skill level.
Therefore, biases that assume these communities are underperformers or less
talented relative to their non-marginalized peers could very easily be reinforced
by marginalized students' underestimating their own abilities. I'm not entirely
sure how people's rating of themselves is going to be factored into creating groups.
However, if a student of a marginalized community who has rated their abilities
a low value gets paired with a non-marginalized student who rated their abilities
with a high value, the non-marginalized student might already have assumptions
that they are the "better" coder and that the other student is "less than." This
type of relationship will then automatically reinforce the marginalized student's
perception or fear that they aren't as good at coding as their counterpart.



What did we not implement?
We decided to prioritize our functionality and ultimately ended up not implementing 
user stories 3 and 4. In the comments of our StudentRecommender class, we have an outline
for the recommender methods that would be used in user stories 3 and 4. 

Here is the outline for how we would have approached user story 3:

Here is the outline for how we would have approached user story 4:
number of groups = (total number of people)/ (group size)
the remaineder (extra people) = total people mod group size (between 1 and 1-n)
   - randomly pick 1 grouop center and their their nn (if empty, use all people instead)
   - randomly choose x from center's nn and remove from global list
   - add x to thihs group and generate its nn
   - randomly choose... repeat until this group = group size
 Repeat this procedure for all of the number of groups; then, 
   (if extra people 0){
    for each extra-person, randomly choose a group
    } else {
    add extra person}
   
